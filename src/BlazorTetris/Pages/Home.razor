@page "/"
@using BlazorTetris.Models
@using BlazorTetris.Services
@using BlazorTetris.Components
@inject GameService Game
@inject AudioService Audio
@implements IAsyncDisposable

<PageTitle>Blazor Tetris</PageTitle>

<div class="game-container"
     tabindex="0"
     @ref="_gameRef"
     @onkeydown="HandleKeyDown"
     @onkeydown:preventDefault="true">

    <!-- Left sidebar -->
    <div class="sidebar sidebar-left">
        <NextPiecePreview Title="Hold" Piece="@Game.State.HeldPiece" />
        <KeyBindingsPanel />
    </div>

    <!-- Centre: board + overlays -->
    <div class="board-wrapper">
        <GameBoard GameState="@Game.State" />

        @if (Game.State.Status == GameStatus.Idle)
        {
            <div class="overlay">
                <h1 class="overlay-title">TETRIS</h1>
                <button class="btn-play" @onclick="StartGame">Start Game</button>
            </div>
        }
        else if (Game.State.Status == GameStatus.Paused)
        {
            <div class="overlay">
                <h2 class="overlay-title">PAUSED</h2>
                <button class="btn-play" @onclick="ResumeGame">Resume</button>
            </div>
        }
        else if (Game.State.Status == GameStatus.GameOver)
        {
            <div class="overlay">
                <h2 class="overlay-title">GAME OVER</h2>
                <p class="overlay-score">Score: @Game.State.Score</p>
                <button class="btn-play" @onclick="StartGame">Play Again</button>
            </div>
        }
    </div>

    <!-- Right sidebar -->
    <div class="sidebar sidebar-right">
        <NextPiecePreview Title="Next" Piece="@Game.State.NextPiece" />
        <ScoreBoard State="@Game.State" />
        <button class="btn-mute" @onclick="ToggleMute" title="Toggle sound">
            @(_muted ? "ðŸ”‡" : "ðŸ”Š")
        </button>
    </div>
</div>

@code {
    private ElementReference _gameRef;
    private bool _muted;

    // Track previous state to detect audio-relevant changes in OnGameStateChanged.
    private int _prevLines;
    private int _prevLevel = 1;
    private GameStatus _prevStatus = GameStatus.Idle;

    protected override void OnInitialized()
    {
        Game.OnStateChanged += OnGameStateChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            await _gameRef.FocusAsync();
    }

    private async Task StartGame()
    {
        _prevLines = 0;
        _prevLevel = 1;
        _prevStatus = GameStatus.Running;
        await Game.StartNewGameAsync();
        await Audio.StartMusicAsync();
        await _gameRef.FocusAsync();
    }

    private async Task ResumeGame()
    {
        Game.PauseOrResume();
        if (!_muted) await Audio.StartMusicAsync();
        await _gameRef.FocusAsync();
    }

    private async Task ToggleMute()
    {
        _muted = await Audio.ToggleMuteAsync();
    }

    private void OnGameStateChanged()
        => InvokeAsync(async () =>
        {
            var s = Game.State;

            // Line clear
            if (s.LinesCleared > _prevLines)
                await Audio.PlayLineClearAsync(s.LinesCleared - _prevLines);

            // Level up (only after a line clear, not on new game reset)
            if (s.Level > _prevLevel && s.LinesCleared > _prevLines)
                await Audio.PlayLevelUpAsync();

            // Game over
            if (s.Status == GameStatus.GameOver && _prevStatus != GameStatus.GameOver)
            {
                await Audio.StopMusicAsync();
                await Audio.PlayGameOverAsync();
            }

            // Pause â€” stop music
            if (s.Status == GameStatus.Paused && _prevStatus == GameStatus.Running)
                await Audio.StopMusicAsync();

            _prevLines  = s.LinesCleared;
            _prevLevel  = s.Level;
            _prevStatus = s.Status;

            StateHasChanged();
        });

    private async void HandleKeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft":
                Game.MoveLeft();
                await Audio.PlayMoveAsync();
                break;
            case "ArrowRight":
                Game.MoveRight();
                await Audio.PlayMoveAsync();
                break;
            case "ArrowDown":
                Game.SoftDrop();
                await Audio.PlayLockAsync();   // soft thud on soft drop
                break;
            case "ArrowUp":
                Game.RotateCW();
                await Audio.PlayRotateAsync();
                break;
            case "z":
            case "Z":
                Game.RotateCCW();
                await Audio.PlayRotateAsync();
                break;
            case " ":
                Game.HardDrop();
                await Audio.PlayHardDropAsync();
                break;
            case "c":
            case "C":
                Game.Hold();
                await Audio.PlayRotateAsync();
                break;
            case "p":
            case "P":
                Game.PauseOrResume();
                break;
        }
    }

    public async ValueTask DisposeAsync()
    {
        Game.OnStateChanged -= OnGameStateChanged;
        await Audio.StopMusicAsync();
        await Game.DisposeAsync();
    }
}
